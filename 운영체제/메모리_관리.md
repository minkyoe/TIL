## 메모리 관리

### 메모리 관리 기법 사용 이유

- 다중 프로그래밍 시스템에
- 여러 프로세스를 수용하기 위해
- 주기억장치를 동적 분할



### 메모리 관리 기법

- 연속 메모리 관리
  - 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함
  - **고정 분할 기법**: 주기억장치가 고정된 파티션으로 분할 -> **내부 단편화 발생**
  - **동적 분할 기법**: 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 -> **외부 단편화 발생**
- 불연속 메모리 관리
  - 프로그램 일부가 서로 다른 주소 공간에 할당 될 수 있는 기법
  - 

### 메모리 관리 배경

- 단편화 (Fragmentation)

  - 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면
  - 프로세스들이 차지하는 메모리 틈사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어남

  1. 외부 단편화
     - 물리 메모리 (RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있음
     - **압축**
       - 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아서 자유공간을 확보함
       - 작업 효율 좋지 않음
  2. 내부 단편화
     - 메모리 분할 자유 공간이 10000B있고 Process A가 9998B 사용하게 되면 2B라는 차이가 존재함



### Paging (페이징)

- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법

- **외부 단편화, 압축 작업을 해소하기 위해 생긴 방법론**

- 물리 메모리 -> Frame으로 분리됨

  논리 메모리(프로세스가 점유하는) -> 페이지로 분리

- 물리 메모리의 남는 프레임에 논리 메모리가 적절히 배치됨

- 하나의 프로세스는 여러개의 페이지로 나뉘어서 관리됨 (논리 메모리에서)

  개별 페이지는 **순서에 상관없이** 물리 메모리에 있는 프레임에 맵핑되어 저장됨

- 단점

  - 내부 단편화 문제 비중이 늘어남

  - ex. 페이지 크기 = 1024B, 프로세스A = 3172B 메모리 요구

    3개의 페이지 프레임(1024*3) + 100B -> 총 4개의 페이지 프레임 필요

    4번째 페이지 프레임에는 924B의 여유 공간이 남게됨



### Segmentation (세그멘테이션)

- 서로 다른 크기의 논리적 단위인 세그먼트로 분할

- 사용자가 두 개의 주소로 지정 (세그먼트 번호 + 변위)

- 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과

  한계(세그먼트의 길이)를 저장

- 주소변환
  - 변위(변하지 않는 값)는 논리주소와 물리주소가 동일함
  - CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트 발생
  - 해당 프로세스 강제 종료시킴

- 단점
  - 외부 단편화
    - 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되면
    - 자유 공간들이 많은 수의 작은 조각들로 나누어져 못쓰게 될수 있음



<br/>

<br/>

<br/>

<br/>

> 참고
>
> https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5
>
> https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Paging%20and%20Segmentation.md
>
> https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/Paging_Segmentation.md